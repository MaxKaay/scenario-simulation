<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquidity Position Simulator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        input[type="number"], input[type="text"], textarea {
            width: 100%;
            box-sizing: border-box;
        }
        textarea {
            height: 100px;
        }
    </style>
</head>
<body>
    <h2>Liquidity Position Simulator</h2>
    <textarea id="csvInput" placeholder="Paste CSV formatted data here..."></textarea>
    <button onclick="parseAndSimulateCSV()">Simulate CSV Data</button>
    <div id="simulations"></div>

    <script>
        function parseCSV(csv) {
            const lines = csv.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const data = lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim());
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = values[index];
                });
                return entry;
            });
            return data;
        }

        function parseAndSimulateCSV() {
            const csvInput = document.getElementById('csvInput').value;
            const data = parseCSV(csvInput);
            data.forEach(row => {
                const precedingAction = row.precedingAction;
                const currentTick = parseFloat(row.currentTick);
                const floorTickLower = parseFloat(row.floorTickLower);
                const floorTickUpper = parseFloat(row.floorTickUpper);
                const floorEth = parseFloat(row.floorEth) / 1e18;
                const floorHarb = parseFloat(row.floorHarb) / 1e18;
                const anchorTickLower = parseFloat(row.anchorTickLower);
                const anchorTickUpper = parseFloat(row.anchorTickUpper);
                const anchorEth = parseFloat(row.anchorEth) / 1e18;
                const anchorHarb = parseFloat(row.anchorHarb) / 1e18;
                const discoveryTickLower = parseFloat(row.discoveryTickLower);
                const discoveryTickUpper = parseFloat(row.discoveryTickUpper);
                const discoveryEth = parseFloat(row.discoveryEth) / 1e18;
                const discoveryHarb = parseFloat(row.discoveryHarb) / 1e18;

                simulate(precedingAction, currentTick, floorTickLower, floorTickUpper, floorEth, floorHarb, anchorTickLower, anchorTickUpper, anchorEth, anchorHarb, discoveryTickLower, discoveryTickUpper, discoveryEth, discoveryHarb);
            });

            // Clear input field after processing
            document.getElementById('csvInput').value = '';
        }

        function simulate(precedingAction, currentTick, floorTickLower, floorTickUpper, floorEth, floorHarb, anchorTickLower, anchorTickUpper, anchorEth, anchorHarb, discoveryTickLower, discoveryTickUpper, discoveryEth, discoveryHarb) {
            // Calculate bar widths based on tick ranges
            var tick_starts = [discoveryTickLower, anchorTickLower, floorTickLower];
            var tick_ends = [discoveryTickUpper, anchorTickUpper, floorTickUpper];
            var liquidity = [
                discoveryEth + discoveryHarb,
                anchorEth + anchorHarb,
                floorEth + floorHarb
            ];
            var eth = [discoveryEth, anchorEth, floorEth];
            var harb = [discoveryHarb, anchorHarb, floorHarb];

            var widths = tick_ends.map((end, i) => end - tick_starts[i]);

            // Determine the buy or sell amount
            let actionAmount = '';
            let additionalInfo = '';

            if (precedingAction.startsWith('buy')) {
                const buyAmount = parseFloat(precedingAction.split(' ')[1]) / 1e18;
                const harbBought = buyAmount; // Assuming buy order converts ETH to HARB
                additionalInfo = `(${harbBought.toFixed(18)} HARB bought)`;
                actionAmount = `Buy ${buyAmount.toFixed(18)}`;
            } else if (precedingAction.startsWith('sell')) {
                const sellAmount = parseFloat(precedingAction.split(' ')[1]) / 1e18;
                const ethBought = sellAmount; // Assuming sell order converts HARB to ETH
                additionalInfo = `(${ethBought.toFixed(18)} ETH bought)`;
                actionAmount = `Sell ${sellAmount.toFixed(18)}`;
            } else {
                actionAmount = precedingAction;
            }

            var data = [
                {
                    x: tick_starts.map((start, i) => start + widths[i] / 2),
                    y: harb,
                    width: widths,
                    type: 'bar',
                    marker: {
                        color: ['green', 'red', 'blue'],
                        opacity: 0.6
                    },
                    text: harb.map((h, i) => `ETH: ${eth[i].toFixed(18)}<br>HARB: ${h.toFixed(18)}`),
                    hoverinfo: 'text',
                    name: 'Liquidity'
                }
            ];

            var layout = {
                title: `Liquidity, ETH, and HARB Distribution - ${actionAmount} ${additionalInfo}`,
                xaxis: {
                    title: 'Ticks',
                    tickvals: tick_starts.concat([currentTick], tick_ends),
                    ticktext: tick_starts.map(String).concat([`${currentTick}\n(Current Price)`], tick_ends.map(String))
                },
                yaxis: {
                    title: 'Liquidity (HARB)'
                },
                shapes: [
                    {
                        type: 'line',
                        x0: currentTick,
                        x1: currentTick,
                        y0: 0,
                        y1: Math.max(...harb) * 1.1,
                        line: {
                            color: 'black',
                            width: 2,
                            dash: 'dash'
                        },
                        name: 'Current Tick'
                    }
                ]
            };

            var newDiv = document.createElement('div');
            newDiv.style.marginBottom = '20px';
            var newHeader = document.createElement('h3');
            newHeader.textContent = `Liquidity, ETH, and HARB Distribution - ${actionAmount} ${additionalInfo}`;
            var newChart = document.createElement('div');
            newChart.style.width = '100%';
            newChart.style.height = '600px';
            var toggleButton = document.createElement('button');
            toggleButton.textContent = 'Toggle ETH/HARB';
            toggleButton.setAttribute('data-isethdisplayed', 'false');
            toggleButton.onclick = function() { toggleData(newChart, eth, harb, tick_starts, tick_ends, widths, currentTick, precedingAction, toggleButton); };
            newDiv.appendChild(newHeader);
            newDiv.appendChild(toggleButton);
            newDiv.appendChild(newChart);
            document.getElementById('simulations').appendChild(newDiv);

            Plotly.newPlot(newChart, data, layout);
        }

        function toggleData(chart, eth, harb, tick_starts, tick_ends, widths, currentTick, precedingAction, button) {
            var isETHDisplayed = button.getAttribute('data-isethdisplayed') === 'true';
            var currentData = isETHDisplayed ? harb : eth;
            var data = [
                {
                    x: tick_starts.map((start, i) => start + widths[i] / 2),
                    y: currentData,
                    width: widths,
                    type: 'bar',
                    marker: {
                        color: ['green', 'red', 'blue'],
                        opacity: 0.6
                    },
                    text: currentData.map((value, i) => `ETH: ${eth[i].toFixed(18)}<br>HARB: ${harb[i].toFixed(18)}`),
                    hoverinfo: 'text',
                    name: 'Liquidity'
                }
            ];

            var layout = {
                title: `Liquidity, ${isETHDisplayed ? 'HARB' : 'ETH'}, and ${isETHDisplayed ? 'ETH' : 'HARB'} Distribution - ${precedingAction}`,
                xaxis: {
                    title: 'Ticks',
                    tickvals: tick_starts.concat([currentTick], tick_ends),
                    ticktext: tick_starts.map(String).concat([`${currentTick}\n(Current Price)`], tick_ends.map(String))
                },
                yaxis: {
                    title: `Liquidity (${isETHDisplayed ? 'HARB' : 'ETH'})`
                },
                shapes: [
                    {
                        type: 'line',
                        x0: currentTick,
                        x1: currentTick,
                        y0: 0,
                        y1: Math.max(...currentData) * 1.1,
                        line: {
                            color: 'black',
                            width: 2,
                            dash: 'dash'
                        },
                        name: 'Current Tick'
                    }
                ]
            };

            button.setAttribute('data-isethdisplayed', (!isETHDisplayed).toString());
            Plotly.react(chart, data, layout);  // Use Plotly.react to update the existing chart
        }
    </script>
</body>
</html>
